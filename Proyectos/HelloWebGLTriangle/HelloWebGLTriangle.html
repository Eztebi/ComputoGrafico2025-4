<!DOCTYPE html>
<html>
<head>
    <title>WebGL Hello Triangle</title>
    <style>
        body { margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #333; }
        canvas { border: 1px solid #000; }
    </style>
</head>
<body>
    <canvas id="glcanvas" width="640" height="480">
        Tu navegador no soporta el elemento HTML5 canvas.
    </canvas>

    <script  id="vertex-shader-2d" type="notjs">
        attribute vec4 a_position;
        attribute vec4 a_color;
        varying lowp vec4 vColor;
        uniform mat4 camera;
        uniform mat4 proyection;
        uniform mat4 model;

        void main() {
          vColor = a_color;
          gl_Position = proyection * camera * model * a_position;
        }
    </script>

    <script  id="fragment-shader-2d" type="notjs">
        precision mediump float;
        varying lowp vec4 vColor;
        void main() {
            // Triángulo Rojo
            gl_FragColor = vColor;
        }
    </script>


    <script id="main" type="text/javascript">
        //https://webglfundamentals.org/webgl/lessons/
        //https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial

        // 1. Shaders GLSL (Lenguaje de Shading de Gráficos)
        // El sombreador de vértices (Vertex Shader) procesa las posiciones de los vértices.
        //const vsSource = `
        //    attribute vec4 a_position;
        //    void main() {
          //        // gl_Position es una variable especial que almacena la posición final del vértice
          //        gl_Position = a_position;
          //    }
          //`;
          //
          //// El sombreador de fragmentos (Fragment Shader) determina el color de cada píxel.
          //const fsSource = `
          //    void main() {
            //        // gl_FragColor es una variable especial que almacena el color final del fragmento (píxel)
            //        // Color RGB(1.0, 0.0, 0.0) es Rojo. El 1.0 final es el valor alfa (opacidad).
            //        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            //    }
            //`;
            
            // Dibuja la escena
            var m4 = {
              
              perspective: function(fieldOfViewInRadians, aspect, near, far) {
                var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);
                var rangeInv = 1.0 / (near - far);
                
                return [
                  f / aspect, 0, 0, 0,
                  0, f, 0, 0,
                  0, 0, (near + far) * rangeInv, -1,
                  0, 0, near * far * rangeInv * 2, 0
                ];
              },
              
              projection: function(width, height, depth) {
                // Note: This matrix flips the Y axis so 0 is at the top.
                return [
                  2 / width, 0, 0, 0,
                  0, -2 / height, 0, 0,
                  0, 0, 2 / depth, 0,
                  -1, 1, 0, 1,
                ];
              },
              
              multiply: function(a, b) {
                var a00 = a[0 * 4 + 0];
                var a01 = a[0 * 4 + 1];
                var a02 = a[0 * 4 + 2];
                var a03 = a[0 * 4 + 3];
                var a10 = a[1 * 4 + 0];
                var a11 = a[1 * 4 + 1];
                var a12 = a[1 * 4 + 2];
                var a13 = a[1 * 4 + 3];
                var a20 = a[2 * 4 + 0];
                var a21 = a[2 * 4 + 1];
                var a22 = a[2 * 4 + 2];
                var a23 = a[2 * 4 + 3];
                var a30 = a[3 * 4 + 0];
                var a31 = a[3 * 4 + 1];
                var a32 = a[3 * 4 + 2];
                var a33 = a[3 * 4 + 3];
                var b00 = b[0 * 4 + 0];
                var b01 = b[0 * 4 + 1];
                var b02 = b[0 * 4 + 2];
                var b03 = b[0 * 4 + 3];
                var b10 = b[1 * 4 + 0];
                var b11 = b[1 * 4 + 1];
                var b12 = b[1 * 4 + 2];
                var b13 = b[1 * 4 + 3];
                var b20 = b[2 * 4 + 0];
                var b21 = b[2 * 4 + 1];
                var b22 = b[2 * 4 + 2];
                var b23 = b[2 * 4 + 3];
                var b30 = b[3 * 4 + 0];
                var b31 = b[3 * 4 + 1];
                var b32 = b[3 * 4 + 2];
                var b33 = b[3 * 4 + 3];
                return [
                  b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,
                  b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,
                  b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,
                  b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,
                  b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,
                  b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,
                  b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,
                  b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,
                  b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,
                  b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,
                  b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,
                  b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,
                  b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,
                  b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,
                  b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,
                  b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,
                ];
              },
              
              translation: function(tx, ty, tz) {
                return [
                  1,  0,  0,  0,
                  0,  1,  0,  0,
                  0,  0,  1,  0,
                  tx, ty, tz, 1,
                ];
              },
              
              xRotation: function(angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                
                return [
                  1, 0, 0, 0,
                  0, c, s, 0,
                  0, -s, c, 0,
                  0, 0, 0, 1,
                ];
              },
              
              yRotation: function(angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                
                return [
                  c, 0, -s, 0,
                  0, 1, 0, 0,
                  s, 0, c, 0,
                  0, 0, 0, 1,
                ];
              },
              
              zRotation: function(angleInRadians) {
                var c = Math.cos(angleInRadians);
                var s = Math.sin(angleInRadians);
                
                return [
                  c, s, 0, 0,
                  -s, c, 0, 0,
                  0, 0, 1, 0,
                  0, 0, 0, 1,
                ];
              },
              
              scaling: function(sx, sy, sz) {
                return [
                  sx, 0,  0,  0,
                  0, sy,  0,  0,
                  0,  0, sz,  0,
                  0,  0,  0,  1,
                ];
              },
              
              translate: function(m, tx, ty, tz) {
                return m4.multiply(m, m4.translation(tx, ty, tz));
              },
              
              xRotate: function(m, angleInRadians) {
                return m4.multiply(m, m4.xRotation(angleInRadians));
              },
              
              yRotate: function(m, angleInRadians) {
                return m4.multiply(m, m4.yRotation(angleInRadians));
              },
              
              zRotate: function(m, angleInRadians) {
                return m4.multiply(m, m4.zRotation(angleInRadians));
              },
              
              scale: function(m, sx, sy, sz) {
                return m4.multiply(m, m4.scaling(sx, sy, sz));
              },
              
              inverse: function(m) {
                var m00 = m[0 * 4 + 0];
                var m01 = m[0 * 4 + 1];
                var m02 = m[0 * 4 + 2];
                var m03 = m[0 * 4 + 3];
    var m10 = m[1 * 4 + 0];
    var m11 = m[1 * 4 + 1];
    var m12 = m[1 * 4 + 2];
    var m13 = m[1 * 4 + 3];
    var m20 = m[2 * 4 + 0];
    var m21 = m[2 * 4 + 1];
    var m22 = m[2 * 4 + 2];
    var m23 = m[2 * 4 + 3];
    var m30 = m[3 * 4 + 0];
    var m31 = m[3 * 4 + 1];
    var m32 = m[3 * 4 + 2];
    var m33 = m[3 * 4 + 3];
    var tmp_0  = m22 * m33;
    var tmp_1  = m32 * m23;
    var tmp_2  = m12 * m33;
    var tmp_3  = m32 * m13;
    var tmp_4  = m12 * m23;
    var tmp_5  = m22 * m13;
    var tmp_6  = m02 * m33;
    var tmp_7  = m32 * m03;
    var tmp_8  = m02 * m23;
    var tmp_9  = m22 * m03;
    var tmp_10 = m02 * m13;
    var tmp_11 = m12 * m03;
    var tmp_12 = m20 * m31;
    var tmp_13 = m30 * m21;
    var tmp_14 = m10 * m31;
    var tmp_15 = m30 * m11;
    var tmp_16 = m10 * m21;
    var tmp_17 = m20 * m11;
    var tmp_18 = m00 * m31;
    var tmp_19 = m30 * m01;
    var tmp_20 = m00 * m21;
    var tmp_21 = m20 * m01;
    var tmp_22 = m00 * m11;
    var tmp_23 = m10 * m01;
    
    var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -
    (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
    var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -
    (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
    var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -
    (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
    var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -
    (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
    
    var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
    
    return [
      d * t0,
      d * t1,
      d * t2,
      d * t3,
      d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -
      (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30)),
      d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -
      (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30)),
      d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -
      (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30)),
      d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -
      (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20)),
      d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -
      (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33)),
      d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -
      (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33)),
      d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -
      (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33)),
      d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -
      (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23)),
      d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -
      (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22)),
      d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -
      (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02)),
      d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -
      (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12)),
      d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -
      (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02))
    ];
  },
  
  vectorMultiply: function(v, m) {
    var dst = [];
    for (var i = 0; i < 4; ++i) {
      dst[i] = 0.0;
      for (var j = 0; j < 4; ++j) {
        dst[i] += v[j] * m[j * 4 + i];
      }
    }
    return dst;
  },
  
  /**
   * Calcula el vector normalizado.
   * @param {number[]} v El vector 3D como [x, y, z].
   * @return {number[]} El vector normalizado.
   */
  normalize: function(v) {
    var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    // Evita la división por cero
    if (length > 0.0000001) {
      return [v[0] / length, v[1] / length, v[2] / length];
    } else {
      return [0, 0, 0];
    }
  },
  
  /**
   * Calcula el producto cruzado de dos vectores.
   * @param {number[]} a El primer vector 3D como [x, y, z].
   * @param {number[]} b El segundo vector 3D como [x, y, z].
   * @return {number[]} El vector producto cruzado.
   */
  cross: function(a, b) {
    return [
      a[1] * b[2] - a[2] * b[1],
      a[2] * b[0] - a[0] * b[2],
      a[0] * b[1] - a[1] * b[0]
    ];
  },
  
  /**
   * Calcula el producto punto (dot product) de dos vectores.
   * @param {number[]} a El primer vector 3D como [x, y, z].
   * @param {number[]} b El segundo vector 3D como [x, y, z].
   * @return {number} El producto punto.
   */
  dot: function(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  },
  
  /**
   * Crea una matriz LookAt.
   * @param {number[]} eye El punto de la cámara [x, y, z].
   * @param {number[]} target El punto al que mira la cámara [x, y, z].
   * @param {number[]} up El vector "arriba" de la cámara [x, y, z].
   * @return {number[]} Una matriz 4x4.
   */
  lookAt: function(eye, target, up) {
    // 1. Calcular el eje Z (Forward) de la cámara.
    // Usamos (eye - target) y normalizamos. Esto apunta desde target hacia eye (en el espacio de la cámara, es -Z).
    // Tu matriz de vista debe transformar los objetos desde el sistema de coordenadas del mundo al sistema de coordenadas de la cámara.
    // DirectX/WebGL usan un sistema de coordenadas a la derecha (Right-Handed System) donde el vector forward de la cámara es -Z.
    var zAxis = [
      eye[0] - target[0],
      eye[1] - target[1],
      eye[2] - target[2],
    ];
    zAxis = m4.normalize(zAxis);
    
    // 2. Calcular el eje X (Right).
    // Es perpendicular al eje Z y al vector Up global.
    var xAxis = m4.cross(m4.normalize(up), zAxis);
    xAxis = m4.normalize(xAxis);
    
    // 3. Calcular el eje Y (Up) de la cámara.
    // Es perpendicular a los ejes Z y X.
    var yAxis = m4.cross(zAxis, xAxis);
    // Ya está normalizado porque zAxis y xAxis lo están y son perpendiculares.
    
    // 4. Crear la matriz LookAt.
    // Esta es una matriz de rotación y traslación inversa (la matriz de vista)
    // donde las filas 0, 1 y 2 contienen los ejes X, Y y Z de la cámara, respectivamente,
    // y la fila 3 contiene la traslación.
    return [
      xAxis[0], xAxis[1], xAxis[2], 0,
      yAxis[0], yAxis[1], yAxis[2], 0,
      zAxis[0], zAxis[1], zAxis[2], 0,
      -(m4.dot(xAxis, eye)), -(m4.dot(yAxis, eye)), -(m4.dot(zAxis, eye)), 1,
    ];
  },
  
};
function clearScreen(gl) {
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    // Limpiar el canvas (fondo azul oscuro)
    gl.clearColor(0.0, 0.0, 0.4, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);

    // Comando de dibujo final: Dibuja 3 vértices como un triángulo.
  
    //gl.drawArrays()
}



        // Compila un shader (vértices o fragmentos)
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Error al compilar el shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function getShaderSource(id) {
            const shaderScript = document.getElementById(id);

            if (!shaderScript) {
                throw new Error(`No se encontró el elemento script con ID: ${id}`);
            }

            // El contenido del script se encuentra en la propiedad textContent
            return shaderScript.textContent.trim();
        }

        // Crea el programa de sombreado combinando los shaders
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
   
            if (!vertexShader || !fragmentShader) 
                return null;

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('No se pudo inicializar el shader:', gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }
        function setUpGeometria(gl, shaderProgram){
             // 3. Crear Geometría (Datos del Triángulo)
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Coordenadas en espacio de recorte (clip space): de -1.0 a +1.0
            const positions = new Float32Array([

                //x      y     z     w
// vertices
//v1 Frente T1
-1.0,  1.0,  1.0, 1.0,
-1.0, -1.0,  1.0, 1.0,
1.0, -1.0,  1.0, 1.0,
//v1 frente T2
-1.0,  1.0,  1.0, 1.0,
1.0, -1.0,  1.0, 1.0,
1.0, 1.0,  1.0, 1.0,

//v2 atras T1
-1.0,  1.0,  -1.0, 1.0,
-1.0, -1.0,  -1.0, 1.0,
1.0, -1.0,  -1.0, 1.0,
//v2 atras T2
-1.0,  1.0,  -1.0, 1.0,
1.0, -1.0,  -1.0, 1.0,
1.0, 1.0,  -1.0, 1.0,

//v3 Derecha T1
1.0, 1.0, 1.0, 1.0,
1.0,  -1.0, 1.0, 1.0,
1.0, -1.0,  -1.0, 1.0,
//v3 DERECHA T2
1.0, 1.0, 1.0, 1.0,
1.0, -1.0,  -1.0, 1.0,
1.0, 1.0,  -1.0, 1.0,

//v4 Izquierda t1
-1.0, 1.0, 1.0, 1.0,
-1.0,  -1.0, 1.0, 1.0,
-1.0, -1.0,  -1.0, 1.0,
//v4 Izquierda T2
-1.0, 1.0, 1.0, 1.0,
-1.0, -1.0,  -1.0, 1.0,
-1.0, 1.0,  -1.0, 1.0,

//v5 Arriba t1
-1.0,  1.0, 1.0, 1.0,
1.0,  1.0,  1.0, 1.0,
 1.0,  1.0, -1.0, 1.0,
 //v5 arriba t2
-1.0,  1.0, 1.0, 1.0,
 1.0,  1.0, -1.0, 1.0,
 -1.0,  1.0, -1.0, 1.0,


 //v6 Abajo t1
-1.0,  -1.0, 1.0, 1.0,
1.0,  -1.0,  1.0, 1.0,
 1.0,  -1.0, -1.0, 1.0,
 //v6 abajo t2
-1.0,  -1.0, 1.0, 1.0,
 1.0,  -1.0, -1.0, 1.0,
 -1.0,  -1.0, -1.0, 1.0,
            ]);
            // Pasar los datos de posición a la GPU
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            // 4. Conectar Geometría al Atributo del Shader
            const positionLocation = gl.getAttribLocation(shaderProgram, 'a_position');
            
            //Habilitar el atributo
            gl.enableVertexAttribArray(positionLocation);
            
            gl.vertexAttribPointer(
                positionLocation, // Localización del atributo
                4,                // Número de componentes por vértice (x, y, z, w)
                gl.FLOAT,         // Tipo de datos en el buffer
                false,            // Normalizar datos (no aplicable aquí)
                0,                // Stride (paso) - 0 significa que los datos están densamente empacados
                0                 // Offset (desplazamiento) - Dónde comenzar
            );

        }
        function setUpColors(gl, shaderProgram){
            
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            const colors = [
                //colores
                //v2blanco
                1.0, 1.0, 1.0, 1.0,
                1.0, 1.0, 1.0, 1.0,
                1.0, 1.0, 1.0, 1.0,
                
                1.0, 1.0, 1.0, 1.0,
                1.0, 1.0, 1.0, 1.0,
                1.0, 1.0, 1.0, 1.0,
//V1 rojo
1.0, 0.0, 0.0, 1.0,
1.0, 0.0, 0.0, 1.0,
1.0, 0.0, 0.0, 1.0,

1.0, 0.0, 0.0, 1.0,
1.0, 0.0, 0.0, 1.0,
1.0, 0.0, 0.0, 1.0,


//v3 verde
0.0, 1.0, 0.0, 1.0,
0.0, 1.0, 0.0, 1.0,
0.0, 1.0, 0.0, 1.0,

0.0, 1.0, 0.0, 1.0,
0.0, 1.0, 0.0, 1.0,
0.0, 1.0, 0.0, 1.0,

//v4 azul
0.0, 0.0, 1.0, 1.0,
0.0, 0.0, 1.0, 1.0,
0.0, 0.0, 1.0, 1.0,

0.0, 0.0, 1.0, 1.0,
0.0, 0.0, 1.0, 1.0,
0.0, 0.0, 1.0, 1.0,

//v5 naranja
 1.0, 0.5, 0.0, 1.0,
 1.0, 0.5, 0.0, 1.0,
 1.0, 0.5, 0.0, 1.0,

 1.0, 0.5, 0.0, 1.0,
 1.0, 0.5, 0.0, 1.0,
 1.0, 0.5, 0.0, 1.0,
 
//v6 amarillo
  1.0, 1.0, 0.0, 1.0,
  1.0, 1.0, 0.0, 1.0,
  1.0, 1.0, 0.0, 1.0,
  
  1.0, 1.0, 0.0, 1.0,
  1.0, 1.0, 0.0, 1.0,
  1.0, 1.0, 0.0, 1.0
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            // Pasar los datos de posición a la GPU
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
            
            // 4. Conectar Geometría al Atributo del Shader
            const colorLocation = gl.getAttribLocation(shaderProgram, 'a_color');

            // Habilitar el atributo
            gl.enableVertexAttribArray(colorLocation);

            // Especificar cómo la GPU debe leer los datos del buffer
            gl.vertexAttribPointer(
                colorLocation, // Localización del atributo
                4,                // Número de componentes por vértice (x, y, z, w)
                gl.FLOAT,         // Tipo de datos en el buffer
                false,            // Normalizar datos (no aplicable aquí)
                0,                // Stride (paso) - 0 significa que los datos están densamente empacados
                0                 // Offset (desplazamiento) - Dónde comenzar
          );
        }
        function main() {
          var eye =  [0,25,-30];
          var center = [0,0,0];
          var translation;
          var proyection;
          var camera;
          var model;
          
          var modelLocation;
          var proyectionLocation;
          var cameraLocation;
            
            let laberintoArray = [  [1,1,1,1,1,0,1,1,1,1],
                                    [1,0,0,0,1,0,0,0,0,1],
                                    [1,0,0,0,1,0,1,1,1,1],
                                    [1,0,1,0,1,0,0,0,1,1],
                                    [1,0,1,0,1,1,1,0,1,1],
                                    [1,0,0,1,0,1,0,0,1,1],
                                    [1,0,0,1,0,1,0,1,0,1],
                                    [1,0,0,0,0,0,0,1,0,1],
                                    [1,0,1,0,1,0,0,1,0,1],
                                    [1,1,1,1,1,0,1,1,1,1]];
            
                                    const canvas = document.getElementById('glcanvas');
                                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                                    
                                    if (!gl) {
                                      alert('No se pudo inicializar WebGL. Tu navegador podría no soportarlo.');
                                      return;
                                    }
                                    
                                    // 2. Inicializar Shaders
                                    const vertexShader = getShaderSource('vertex-shader-2d')
                                    const fragmentShader = getShaderSource('fragment-shader-2d')
                                    
                                    const shaderProgram = initShaderProgram(gl, vertexShader, fragmentShader);
                                    
                                    if (!shaderProgram) return;
                                    // Usar el programa recién creado
                                    gl.useProgram(shaderProgram);
                                    
                                    //geometria
                                    setUpGeometria(gl,shaderProgram);
                                    //colores
                                    setUpColors(gl,shaderProgram);
                                    
                                    clearScreen(gl);
                                    modelLocation = gl.getUniformLocation(shaderProgram, "model");
                                    cameraLocation = gl.getUniformLocation(shaderProgram, "camera");
                                    proyectionLocation = gl.getUniformLocation(shaderProgram, "proyection");
                                    
                                    proyection = m4.perspective((45.0 * Math.PI/180), 1024.0 / 768.0, 0.1, 500.0);
                                    
                                    
                                    camera = m4.lookAt(eye, center, [0,1,0]);
                                    translation = m4.translation(0,0,0);
                                    
                                    model = translation;
                                    
                                    gl.uniformMatrix4fv(modelLocation, false, model);
                                    gl.uniformMatrix4fv(proyectionLocation, false, proyection);
                                    gl.uniformMatrix4fv(cameraLocation, false, camera);
                                    //gl.drawArrays(gl.TRIANGLES, 0, 36);
                                    //drawScene(gl, 36);
                                    var posY = -5 * 2;
                                    var posX = -5 * 2;
                                    for (var i = 0; i < 10; i++){
                                      for(var j = 0; j < 10; j++){
                                        if(laberintoArray[i][j] == 1){
                                          translation = m4.translation(posX,0,posY);
                                          model = translation;
                                          gl.uniformMatrix4fv(modelLocation, false, model);
                                          gl.drawArrays(gl.TRIANGLES, 0, 36);
                                        }
                                        posX = posX + 2;
                                      }
                                        posY = posY + 2;
                                        posX = -5 * 2;
                                      }
                                    
                                    
                                    // 5. Dibujar
                                  }
                                  
                                  // Ejecutar la función principal al cargar la página
                                  window.onload = main;
                                  
                                  </script>
</body>
</html>